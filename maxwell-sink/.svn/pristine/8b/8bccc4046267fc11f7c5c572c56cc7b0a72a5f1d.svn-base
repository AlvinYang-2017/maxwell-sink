package com.cimc.maxwell.sink.db;

import com.alibaba.fastjson.JSON;
import com.cimc.maxwell.sink.MySqlSinkConfig;
import com.cimc.maxwell.sink.filter.ConditionFilter;
import com.cimc.maxwell.sink.row.ExportRowMap;
import com.cimc.maxwell.sink.row.RowMap;
import org.apache.commons.lang3.StringUtils;
import org.apache.kafka.connect.sink.SinkRecord;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.sql.*;
import java.util.*;

/**
 * Created by 00013708 on 2017/8/9.
 */
public final class MysqlDbWriter {
    private static final Logger log = LoggerFactory.getLogger(MysqlDbWriter.class);

    private static final Logger datalog = LoggerFactory.getLogger("datalog");

    private Connection connection;
    private int VALIDATE_CONNECTION_TIMEOUT = 1000;

    private List<String> sqlBuffer = null;
    private final MySqlSinkConfig config;

    private final SqlAssembler assembler;

    private final Map<String, String> topicDbMap;

    private final ConditionFilter filter;

    public MysqlDbWriter(MySqlSinkConfig config) {
        this.config = config;
        this.topicDbMap = initTopicDbMap(config.topicTargetDB);
        this.assembler = new SqlAssembler(config.tablesPK);
        this.filter = new ConditionFilter(config.filterConditions);
    }


    /**
     * 消费的主题和导入的db对应关系
     *
     * @param topicTargetDB example:estation.db_ez.t_parcel:db_ez,estation.db_ez.t_box:db_ez
     * @return example: {"estation.db_ez.t_parcel" : "db_ez","estation.db_ez.t_box" : "db_ez"}
     */
    private Map<String, String> initTopicDbMap(String topicTargetDB) {
        if (StringUtils.isEmpty(topicTargetDB)) {
            log.warn("topicTargetDb config null");
            throw new IllegalArgumentException("topicTargetDb config null");
        }
        final Map<String, String> map = new HashMap<>();
        String[] topicDbPairs = topicTargetDB.split(",");
        for (String pair : topicDbPairs) {//有重复代码，可以统一处理
            String[] arr = pair.split(":");
            String topic = arr[0];
            String db = arr[1];
            map.put(topic, db);
        }
        return map;
    }

    //首先尝试获取一个连接，如果连接是非法的新建一个连接，此连接不释放，作为一个Cache的连接
    public synchronized Connection getValidConnection() throws SQLException {
        if (connection != null && connection.isValid(VALIDATE_CONNECTION_TIMEOUT)) {
            return connection;
        } else {
            connection = createNewConnection();
            return connection;
        }
    }

    private Connection createNewConnection() {
        try {
            Class.forName(config.mysqlDriver);
            Connection connection = DriverManager.getConnection(config.mysqlUrl, config.mysqlUsername,
                    config.mysqlPassword);
            return connection;
        } catch (ClassNotFoundException e) {
            log.error(e.getMessage(), e);
        } catch (SQLException e) {
            log.error(e.getMessage(), e);
        }
        return null;
    }

    public int write(String sql) throws SQLException {
        if (StringUtils.isEmpty(sql)) {
            return 0;
        }
        Connection connection = getValidConnection();

        PreparedStatement ps = connection.prepareStatement(sql);
        log.info("Execute SQL:{}", sql);
        int updateCount = ps.executeUpdate();
        ps.close();
        return updateCount;
    }

    public void write2Buffer(String sql) throws SQLException {
        //这个还要考虑不同的table，也就是不同的connection中执行？
        //不同的表不同的buffer？不考虑那么多，就考虑一个表
        if (sqlBuffer == null || sqlBuffer.isEmpty()) {
            sqlBuffer = new ArrayList<>(config.batchSize);
        }
        sqlBuffer.add(sql);
        if (sqlBuffer.size() == config.batchSize) {
            flush(sqlBuffer);
            sqlBuffer.clear();
        }
    }


    public void batchWrite(Collection<SinkRecord> records) throws SQLException {
        if (records == null || records.isEmpty()) {
            return;
        }
        for (SinkRecord record : records) {
            String topic = record.topic();
            String val = (String) record.value();
            log.info("Record val:{}", val);
            RowMap rowMap = JSON.parseObject(val, RowMap.class);
            /**数据过滤**/
            if (filter.match(rowMap)) {
                //需要输出到文件的前后数据变化
                ExportRowMap exportRowMap = new ExportRowMap(rowMap, assembler.getPk(rowMap.getDatabase() + "." + rowMap.getTable()));
                datalog.info(exportRowMap.toString());
                //判断是否要根据topic替换目标数据库
                if (topicDbMap.containsKey(topic)) {
                    String targetDb = topicDbMap.get(topic);
                    log.info("Replace database:{} to target:{}", rowMap.getDatabase(), targetDb);
                    rowMap.setDatabase(targetDb);
                }
                String sql = assembler.getSql(rowMap);
                try {
                    if (StringUtils.isNotEmpty(sql)) {
                        write2Buffer(sql);
                    }
                } catch (SQLException e) {
                    log.error(e.getMessage(), e);
                }
            }
        }
    }

    /**
     * 返回是否成功执行
     *
     * @param sqlBatch
     * @return
     * @throws SQLException
     */
    public boolean flush(List<String> sqlBatch) throws SQLException {
        if (sqlBatch == null || sqlBatch.isEmpty()) {
            return false;
        }
        Connection connection = getValidConnection();
        connection.setAutoCommit(false);
        Statement statement = connection.createStatement();
        for (String sql : sqlBatch) {
            statement.addBatch(sql);
        }
        int[] updateCoutArr = statement.executeBatch();

        connection.commit();
        statement.close();
        if (updateCoutArr.length == sqlBatch.size()) {
            return true;
        } else {
            return false;
        }
    }

    public synchronized void close() {
        try {
            if (connection != null && !connection.isClosed()) {
                connection.close();
            }
        } catch (SQLException e) {
            log.error(e.getMessage(), e);
        } finally {//强制释放
            connection = null;
        }
    }

    //从maxwell db中查询出来，废弃
    /*private Map<String,Map<String,String>> initTablesPk(String topics) {
        if(StringUtils.isEmpty(topics)){
            throw new IllegalArgumentException("topics empty");
        }
        Map<String,Map<String,String>>  map = new HashMap<>();
        String[] topicArr = topics.split(",");
        for(String topic:topicArr){
            String[] arr = topic.split(",");
            String dbName = arr[1];
            String tbName = arr[2];
            //从数据库中查询出对应的pk值
            String sql = "select pk from `databases` d,`tables` t where d.id = t.database_id and d.`name` = ? and t.`name` = ?";
        }
    }*/

}
